#!/usr/bin/env python3
import itertools
import textwrap
import toml
import sys
import os
import argparse
import string

# * update
# * config
# * resolver
# * list --broken
# * new
# * add

if not os.path.exists('_depot'):
    os.system('git clone --single-branch --branch snapshot https://gitlab.com/simon.hudon/lean-depot.git/ _depot')

l = {}

def user_command(name, parser = None):
    if not parser:
        parser = argparse.ArgumentParser()
    def decorator(func):
        parser.description = func.__doc__
        l[name] = (func, parser)
        return func
    return decorator

def inline_table(d):
    res = toml.decoder.TomlDecoder()
    res = res.get_empty_inline_table()
    res.update(d)
    return res

def is_prefix_of(x,y):
    return x == y[:len(x)]

def snapshot_name(fn):
    """ `fn` should be of the shape `snapshot-2019-10.toml` and `snapshot_name(fn)` will 
    return `2019-10`. For a `snapshot.toml` name, the snapshot name is deemed to be `nightly` """
    (base,ext) = os.path.splitext(fn)
    if base == 'snapshot':
        return 'nightly'
    else:
        return base[len('snapshot')+1:]

def get_depot(lean_version):
    dir = os.getcwd()
    os.chdir(f'_depot/{lean_version}')
    try:
        os.system(f'git fetch --all')
        vs = { snapshot_name(v) : os.path.abspath(v)
                for v in os.listdir('.')
                if (os.path.splitext(v)[1] == '.toml'
                    and is_prefix_of('snapshot',v))}
        return vs

    finally:
        os.chdir(dir)

def load_snapshot(fn):
    def to_list(v):
        if isinstance(v, list): return v
        else: return [v]
    snap = toml.load(fn)
    snap = { git : { 'name': k, 'rev': v['rev'] }
             for (k,v) in snap['snapshot'].items()
             for git in to_list(v['git']) }
    return snap

def find_best_match(prj):
    tag   = prj['package']['lib_snapshot']
    vers  = prj['package']['lean_version']
    deps  = prj['dependencies']
    depot = get_depot(vers)
    depot = [ (k, load_snapshot(v))
                  for (k,v) in depot.items() ]
                          # key=lambda x: x[0])
    depot = [ k
              for (k,v) in depot
              if len([ k2 for k2 in deps.values()
                       if k2 not in v ]) == 0 ]
    depot.remove('nightly')
    # `depot` is expected to hold a set of snapshots labelled by dates and one labelled by `nightly`.
    # `nightly` is a last resort for the snapshots
    if len(depot) == 0: snap = 'nightly'
    else: snap = max(depot)
    return snap

def wrap_indent(m, t, n):
    m = ''.ljust(m)
    return ("\n".join([ m + x for x in textwrap.wrap(t, n)]))

@user_command('configure')
def configure():
    """setup leanpkg configuration"""

    prj = toml.load('lean-depot.toml')
    name = prj['package']['name']
    tag  = prj['package']['lib_snapshot']
    vers = prj['package']['lean_version']
    depot = toml.load(get_depot(vers)[tag])
    # print(depot)
    # print(prj)
    snapshot = { v['git'][0] : v['rev'] for (k,v) in depot['snapshot'].items() }
    deps = { k : inline_table({ 'git' : v, 'rev' : snapshot[v] })
             for (k,v) in prj['dependencies'].items() }
    deps.update( prj['extra_deps'].items()  )
    leanpkg = { 'package' : { 'name' : name,
                              'lean_version' : vers,
                              'path' : 'src',
                              'version' : '0.1' },
                'dependencies' : deps }
    with open('leanpkg.toml', 'w') as h:
        h.write(toml.encoder.dumps(leanpkg, toml.encoder.TomlPreserveInlineDictEncoder()))
        h.write('# generated by lean-depot\n')
        h.write('#   * edit lean-depot.toml and not this file\n')
    os.system('leanpkg configure')

@user_command('init')
def init():
    """create lean-depot configuration from leanpkg file"""
    leanpkg = toml.load(f'leanpkg.toml')
    name         = leanpkg['package']['name']
    lean_version = leanpkg['package']['lean_version']
    lean_version = str.split(lean_version,':')[-1]
    depot = get_depot(lean_version)
    if len(depot) <= 1:
        snapshot = 'nightly'
    else:
        snapshot = max(filter(lambda x: x != 'nightly', depot.keys()))
    all_deps = leanpkg['dependencies']
    deps = { k : v['git'][0] for (k,v) in all_deps.items()
             if 'git' in v }
    ext_deps =  { k : v for (k,v) in all_deps.items()
                      if 'git' not in v }
    prj = {}
    prj['package'] = { 'name' : name,
                       'lean_version' : lean_version,
                       'lib_snapshot' : snapshot }
    prj['dependencies'] = deps
    prj['extra_deps'] = ext_deps
    with open('lean-depot.toml', 'w') as h:
        h.write(toml.encoder.dumps(prj, toml.encoder.TomlPreserveInlineDictEncoder()))

add_parser = argparse.ArgumentParser()
add_parser.add_argument('pkg', # required=False,
                            type=str,
                            help='an integer for the accumulator')

@user_command('add', add_parser)
def add_dep(pkg):
    """add dependency"""
    prj = toml.load('lean-depot.toml')
    tag  = prj['package']['lib_snapshot']
    vers = prj['package']['lean_version']
    depot = toml.load(get_depot(vers)[tag])['snapshot']
    # print(depot)
    if pkg in depot:
        prj['dependencies'][pkg] = depot[pkg]['git'][0]
        with open('lean-depot.toml', 'w') as h:
            h.write(toml.encoder.dumps(prj, toml.encoder.TomlPreserveInlineDictEncoder()))
    else:
        print(f'package not found in current snapshot \'{pkg}\'')
    configure()

@user_command('update')
def update():
    """use latest snapshot"""
    prj   = toml.load('lean-depot.toml')
    snap  = find_best_match(prj)
    prj['package']['lib_snapshot'] = snap
    with open('lean-depot.toml', 'w') as h:
        h.write(toml.encoder.dumps(prj, toml.encoder.TomlPreserveInlineDictEncoder()))
    configure()

new_parser = argparse.ArgumentParser()
new_parser.add_argument('name', # required=False,
                            type=str,
                            help='name of new package')

@user_command('new', new_parser)
def new(name):
    """create new package configuration"""
    prj = { 'package' : { 'name' : name,
                          'lean_version' : '3.4.2',
                          'lib_snapshot' : 'nightly' },
            'dependencies' : {},
            'extra_deps' : {} }
    snap  = find_best_match(prj)
    prj['package']['lib_snapshot'] = snap
    with open('lean-depot.toml', 'w') as h:
        h.write(toml.encoder.dumps(prj, toml.encoder.TomlPreserveInlineDictEncoder()))
    configure()

make_parser = argparse.ArgumentParser()
make_parser.add_argument('path', # required=False,
                            type=str,
                            help='path to new snapshot file')

@user_command('make_snapshot', make_parser)
def make_snapshot(path):
    """create snapshot file from a set of package descriptions"""
    pkgs = { os.path.splitext(fn)[0] : toml.load(f'pkgs/{fn}')['package']
             for fn in os.listdir('pkgs')
             if os.path.splitext(fn)[1] == '.toml' }
    print(pkgs)

    snap = { 'snapshot' : { k : { 'git' : pkg['url'],
                                  'rev' : pkg['commit'],
                                  'desc' : pkg['description'] }
                                for (k,pkg) in pkgs.items() } }
    with open(path, 'w') as h:
        toml.dump(snap, h)

@user_command('resolver')
def resolver():
    """find snapshots to accomodate all dependencies"""
    prj   = toml.load('lean-depot.toml')
    snap  = find_best_match(prj)
    prj['package']['lib_snapshot'] = snap
    with open('lean-depot.toml', 'w') as h:
        h.write(toml.encoder.dumps(prj, toml.encoder.TomlPreserveInlineDictEncoder()))
    configure()

@user_command('list')
def list_packages():
    """list available packages"""
    prj   = toml.load('lean-depot.toml')
    tag   = prj['package']['lib_snapshot']
    vers  = prj['package']['lean_version']
    deps  = prj['dependencies']
    depot = toml.load(get_depot(vers)[tag])
    for (k,v) in depot['snapshot'].items():
        print(k)
        print(wrap_indent(2, v['desc'], 60))
        print('')

@user_command('snapshot')
def snapshot():
    """list available snapshots"""
    prj   = toml.load('lean-depot.toml')
    vers  = prj['package']['lean_version']
    depot = get_depot(vers)
    for (k,v) in depot.items():
        print(k)
        print(wrap_indent(2, ', '.join(toml.load(v)['snapshot'].keys()), 60))

@user_command('nightly')
def nightly():
    """test package against nightly snapshot (not implemented)"""
    print("not implemented")

parser = argparse.ArgumentParser()
parser.add_argument('cmd', choices=l.keys(), # required=False,
                    help='command to get information on')

@user_command('--help', parser)
def help(cmd):
    """provide this help screen"""
    usage()

def usage():
    w = max([ len(i) for i in l.keys() ])
    print(f'usage: {sys.argv[0]} [-h]')
    print('')
    print('Use currated set of Lean packages')
    print('')
    print('positional arguments:')
    for (k,v) in l.items():
        if k != '--help':
            print(f'  {str.ljust(k,w+3)}{v[0].__doc__}')

    print('')
    print('optional arguments:')
    print('  -h, --help  show this help message and exit')

if __name__ == '__main__':
    argv = sys.argv
    if len(argv) > 1 and argv[1] in l:
         (f,parser) = l[argv[1]]
         if parser:
             args = parser.parse_args(argv[2:])
             f(**args.__dict__)
         elif len(argv) == 2:
             f()
         else:
             usage()
    else:
        usage()
